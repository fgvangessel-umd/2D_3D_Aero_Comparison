import picklefrom random import randrangeimport numpy as npfrom sklearn.preprocessing import StandardScalerfrom sklearn.gaussian_process import GaussianProcessRegressorfrom sklearn.gaussian_process.kernels import RBF, Maternfrom matplotlib import pyplot as pltfig, axs = plt.subplots(ncols=3, nrows=1, figsize=(18,30), tight_layout=True)def scale(x, xtest):    scaler = StandardScaler()    scaler.fit(x)    x = scaler.transform(x)    xtest = scaler.transform(xtest)    return x, xtest, scaler# Define GP kerneln_features = 4#kernel = 1 * RBF(length_scale=np.ones(n_features), length_scale_bounds=[(1e-5, 1e5) for i in range(n_features)])kernel = 1.0 * Matern(length_scale=np.ones(n_features), length_scale_bounds=[(1e-5, 1e5) for i in range(n_features)], nu=1.5)# Define GPR fitting routinedef fit_gpr(X, Y, kernel):    gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9, random_state=0)    gp.fit(X, Y)        kernel = gp.kernel_    lml = gp.log_marginal_likelihood_value_        return gp, kernel, lmlfor i in range(9):    if i>9:        break    print('Held Out Slice Index %i:' %i)    for j, var in enumerate(['C_p', 'Vx', 'Vy']):        with open("data.pickle", "rb") as f:            data = pickle.load(f)                    Xb, Xt, Yb, Yt = data                # Use 8:1 train:test split of data         nslice = len(Xb)                Xb_test, Xt_test, Yb_test, Yt_test = Xb[i], Xt[i], Yb[i], Yt[i]        Xb_train, Xt_train, Yb_train, Yt_train = Xb[:i]+Xb[i+1:], Xt[:i]+Xt[i+1:], Yb[:i]+Yb[i+1:], Yt[:i]+Yt[i+1:]                # Concatenate feature/target arrays        Xb_train = np.vstack(tuple(Xb_train))        Xt_train = np.vstack(tuple(Xt_train))        Yb_train = np.vstack(tuple(Yb_train))        Yt_train = np.vstack(tuple(Yt_train))                # Keep only first column of target (Cp)        Yb_train = Yb_train[:,j].reshape((-1,1))        Yt_train = Yt_train[:,j].reshape((-1,1))        Yb_test  = Yb_test[:,j].reshape((-1,1))        Yt_test  = Yt_test[:,j].reshape((-1,1))                        # Apply standard scaler to inputs and targets        Xb_train, Xb_test, scaler_Xb = scale(Xb_train, Xb_test)        Xt_train, Xt_test, scaler_Xt = scale(Xt_train, Xt_test)        Yb_train, Yb_test, scaler_Yb = scale(Yb_train, Yb_test)        Yt_train, Yt_test, scaler_Yt = scale(Yt_train, Yt_test)                        # Fit kernel        gp_b, kernel_b, lml_b = fit_gpr(Xb_train, Yb_train, kernel)        gp_t, kernel_t, lml_t = fit_gpr(Xt_train, Yt_train, kernel)                # Print fitted GP kernel and LML        print('Fluid Variable: '+var)        print('Bottom / Top Fitted GPR Kernel: ')        print(kernel_b, kernel_t)        print('Bottom / Top Fitted GPR LML: %3.2e / %3.2e'%(lml_b, lml_t))                # Make prediction on test data        yb_mean, yb_std = gp_b.predict(Xb_test, return_std=True)        yt_mean, yt_std = gp_t.predict(Xt_test, return_std=True)                print('Bottom / Top Train R2: %3.2e / %3.2e'% (gp_b.score(Xb_train, Yb_train), gp_t.score(Xt_train, Yt_train)))        print('Bottom / Top Test R2: %3.2e / %3.2e'% (gp_b.score(Xb_test, Yb_test), gp_t.score(Xt_test, Yt_test)))                    axs[i].scatter(Xb_test[:,0], Yb_test, c='r', label='Ground Truth')        axs[i].plot(Xb_test[:,0], yb_mean, 'r', label='Mean Prediction (Bot.)')        axs[i].fill_between(Xb_test[:,0], yb_mean - 1.96*yb_std, yb_mean + 1.96*yb_std, alpha=0.5, color='r', label=r"95% confidence interval (Bot.)")                axs[i].scatter(Xt_test[:,0], Yt_test, c='b')        axs[i].plot(Xt_test[:,0], yt_mean, 'b', label='Mean Prediction (Top)')        axs[i].fill_between(Xt_test[:,0], yt_mean - 1.96*yt_std, yt_mean + 1.96*yt_std, alpha=0.5, color='b')            axs[1].legend(loc='upper right', bbox_to_anchor=(0.8, 0.9),           ncol=1, fancybox=True, shadow=True, fontsize=20)for ax in axs:    ax.set_xlabel('Airfoil Length Parameter (s)')axs[0].set_title('Coeff. of Pressure', fontsize=20)axs[1].set_title('Velocity-X', fontsize=20)axs[2].set_title('Velocity-Y', fontsize=20)plt.savefig('gpr.png')